From: Ben Hutchings <ben@decadent.org.uk>
Date: Tue, 13 Aug 2019 13:49:05 +0100
Subject: inet: Avoid ABI change for IP ID hash change
Forwarded: not-needed

"inet: switch IP ID generator to siphash" adds a new member to struct
netns_ipv4.  Since this is embedded in struct net, it changes the
offsets of all the following members.  However struct net itself is
not embedded in anything, and is always allocated by built-in code.
So move the new member to the end of struct net, and hide it from
genksyms.

Also hide the added element and member from modules, as they won't be
able to rely on their being present until we bump ABI.

"ipv4: hash net ptr into fragmentation bucket selection" and "ipv6:
hash net ptr into fragmentation bucket selection" add a net namespace
parameter to __ip_select_ident() and ipv6_proxy_select_ident().  To
avoid an ABI change, rename the new versions of these functions with a
"_net" suffix, and add back the old versions as wrappers passing
&init_net.  Add macros mapping the old names to the new functions,
so newly built modules will get the new versions.

---
--- a/include/net/net_namespace.h
+++ b/include/net/net_namespace.h
@@ -133,6 +133,9 @@ struct net {
 #endif
 	struct sock		*diag_nlsk;
 	atomic_t		fnhe_genid;
+#if !defined(__GENKSYMS__) && !defined(MODULE)
+	siphash_key_t		ipv4_ip_id_key;
+#endif
 };
 
 #include <linux/seq_file_net.h>
--- a/include/net/netns/ipv4.h
+++ b/include/net/netns/ipv4.h
@@ -99,6 +99,6 @@ struct netns_ipv4 {
 #endif
 #endif
 	atomic_t	rt_genid;
-	siphash_key_t	ip_id_key;
+	/* siphash_key_t ip_id_key; - bwh: moved to end of struct net */
 };
 #endif
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -484,22 +484,30 @@ u32 ip_idents_reserve(u32 hash, int segs
 }
 EXPORT_SYMBOL(ip_idents_reserve);
 
-void __ip_select_ident(struct net *net, struct iphdr *iph, int segs)
+#undef __ip_select_ident
+
+void __ip_select_ident_net(struct net *net, struct iphdr *iph, int segs)
 {
 	u32 hash, id;
 
 	/* Note the following code is not safe, but this is okay. */
-	if (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))
-		get_random_bytes(&net->ipv4.ip_id_key,
-				 sizeof(net->ipv4.ip_id_key));
+	if (unlikely(siphash_key_is_zero(&net->ipv4_ip_id_key)))
+		get_random_bytes(&net->ipv4_ip_id_key,
+				 sizeof(net->ipv4_ip_id_key));
 
 	hash = siphash_3u32((__force u32)iph->daddr,
 			    (__force u32)iph->saddr,
 			    iph->protocol,
-			    &net->ipv4.ip_id_key);
+			    &net->ipv4_ip_id_key);
 	id = ip_idents_reserve(hash, segs);
 	iph->id = htons(id);
 }
+EXPORT_SYMBOL(__ip_select_ident_net);
+
+void __ip_select_ident(struct iphdr *iph, int segs)
+{
+	return __ip_select_ident_net(&init_net, iph, segs);
+}
 EXPORT_SYMBOL(__ip_select_ident);
 
 static void __build_flow_key(struct flowi4 *fl4, const struct sock *sk,
--- a/net/ipv6/output_core.c
+++ b/net/ipv6/output_core.c
@@ -22,11 +22,11 @@ static u32 __ipv6_select_ident(struct ne
 	u32 hash, id;
 
 	/* Note the following code is not safe, but this is okay. */
-	if (unlikely(siphash_key_is_zero(&net->ipv4.ip_id_key)))
-		get_random_bytes(&net->ipv4.ip_id_key,
-				 sizeof(net->ipv4.ip_id_key));
+	if (unlikely(siphash_key_is_zero(&net->ipv4_ip_id_key)))
+		get_random_bytes(&net->ipv4_ip_id_key,
+				 sizeof(net->ipv4_ip_id_key));
 
-	hash = siphash(&combined, sizeof(combined), &net->ipv4.ip_id_key);
+	hash = siphash(&combined, sizeof(combined), &net->ipv4_ip_id_key);
 
 	/* Treat id of 0 as unset and if we get 0 back from ip_idents_reserve,
 	 * set the hight order instead thus minimizing possible future
@@ -39,6 +39,8 @@ static u32 __ipv6_select_ident(struct ne
 	return id;
 }
 
+#undef ipv6_proxy_select_ident
+
 /* This function exists only for tap drivers that must support broken
  * clients requesting UFO without specifying an IPv6 fragment ID.
  *
@@ -47,7 +49,7 @@ static u32 __ipv6_select_ident(struct ne
  *
  * The network header must be set before calling this.
  */
-void ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb)
+void ipv6_proxy_select_ident_net(struct net *net, struct sk_buff *skb)
 {
 	struct in6_addr buf[2];
 	struct in6_addr *addrs;
@@ -63,6 +65,12 @@ void ipv6_proxy_select_ident(struct net
 	id = __ipv6_select_ident(net, &addrs[1], &addrs[0]);
 	skb_shinfo(skb)->ip6_frag_id = htonl(id);
 }
+EXPORT_SYMBOL_GPL(ipv6_proxy_select_ident_net);
+
+void ipv6_proxy_select_ident(struct sk_buff *skb)
+{
+	ipv6_proxy_select_ident_net(&init_net, skb);
+}
 EXPORT_SYMBOL_GPL(ipv6_proxy_select_ident);
 
 void ipv6_select_ident(struct net *net, struct frag_hdr *fhdr,
--- a/include/net/ip.h
+++ b/include/net/ip.h
@@ -319,6 +319,7 @@ static inline unsigned int ip_skb_dst_mt
 }
 
 u32 ip_idents_reserve(u32 hash, int segs);
+#define __ip_select_ident __ip_select_ident_net
 void __ip_select_ident(struct net *net, struct iphdr *iph, int segs);
 
 static inline void ip_select_ident_segs(struct net *net, struct sk_buff *skb,
--- a/include/net/ipv6.h
+++ b/include/net/ipv6.h
@@ -690,6 +690,7 @@ static inline int ipv6_addr_diff(const s
 
 void ipv6_select_ident(struct net *net, struct frag_hdr *fhdr,
 		       struct rt6_info *rt);
+#define ipv6_proxy_select_ident ipv6_proxy_select_ident_net
 void ipv6_proxy_select_ident(struct net *net, struct sk_buff *skb);
 
 int ip6_dst_hoplimit(struct dst_entry *dst);
