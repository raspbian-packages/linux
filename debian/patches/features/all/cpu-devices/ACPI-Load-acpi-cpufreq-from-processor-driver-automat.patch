From: Andi Kleen <ak@linux.intel.com>
Date: Thu, 26 Jan 2012 00:09:08 +0100
Subject: ACPI: Load acpi-cpufreq from processor driver automatically

commit 9061e0e16700ef228837e96987ff51794c956197 upstream.

The only left over hole in automatic cpufreq driver loading was the loading
of ACPI cpufreq. This driver should be loaded when ACPI supports a _PDC
method and the CPU vendor wants to use acpi cpufreq.

Simply add a request module call to the acpi processor core driver
when this is true. This seems like the simplest solution for this.

Cc: Len Brown <lenb@kernel.org>
Signed-off-by: Andi Kleen <ak@linux.intel.com>
Signed-off-by: Thomas Renninger <trenn@suse.de>
Acked-by: H. Peter Anvin <hpa@zytor.com>
Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
---
 drivers/acpi/processor_driver.c  |    1 +
 drivers/acpi/processor_perflib.c |   22 ++++++++++++++++++++++
 include/acpi/processor.h         |    1 +
 3 files changed, 24 insertions(+)

Index: linux-3.2.46/drivers/acpi/processor_driver.c
===================================================================
--- linux-3.2.46.orig/drivers/acpi/processor_driver.c	2013-07-26 19:22:54.000000000 +0000
+++ linux-3.2.46/drivers/acpi/processor_driver.c	2013-07-26 19:23:17.000000000 +0000
@@ -500,6 +500,7 @@
 
 #ifdef CONFIG_CPU_FREQ
 	acpi_processor_ppc_has_changed(pr, 0);
+	acpi_processor_load_module(pr);
 #endif
 	acpi_processor_get_throttling_info(pr);
 	acpi_processor_get_limit_info(pr);
Index: linux-3.2.46/drivers/acpi/processor_perflib.c
===================================================================
--- linux-3.2.46.orig/drivers/acpi/processor_perflib.c	2013-07-26 18:54:39.000000000 +0000
+++ linux-3.2.46/drivers/acpi/processor_perflib.c	2013-07-26 19:23:18.000000000 +0000
@@ -240,6 +240,28 @@
 	acpi_processor_ppc_status &= ~PPC_REGISTERED;
 }
 
+/*
+ * Do a quick check if the systems looks like it should use ACPI
+ * cpufreq. We look at a _PCT method being available, but don't
+ * do a whole lot of sanity checks.
+ */
+void acpi_processor_load_module(struct acpi_processor *pr)
+{
+	static int requested;
+	acpi_status status = 0;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+
+	if (!arch_has_acpi_pdc() || requested)
+		return;
+	status = acpi_evaluate_object(pr->handle, "_PCT", NULL, &buffer);
+	if (!ACPI_FAILURE(status)) {
+		printk(KERN_INFO PREFIX "Requesting acpi_cpufreq\n");
+		request_module_nowait("acpi_cpufreq");
+		requested = 1;
+	}
+	kfree(buffer.pointer);
+}
+
 static int acpi_processor_get_performance_control(struct acpi_processor *pr)
 {
 	int result = 0;
Index: linux-3.2.46/include/acpi/processor.h
===================================================================
--- linux-3.2.46.orig/include/acpi/processor.h	2013-07-26 18:54:39.000000000 +0000
+++ linux-3.2.46/include/acpi/processor.h	2013-07-26 19:23:18.000000000 +0000
@@ -224,6 +224,7 @@
 	} piix4;
 };
 
+extern void acpi_processor_load_module(struct acpi_processor *pr);
 extern int acpi_processor_preregister_performance(struct
 						  acpi_processor_performance
 						  __percpu *performance);
