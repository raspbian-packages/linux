From: Daniel Wagner <wagi@monom.org>
Date: Wed, 13 Jul 2022 15:02:30 +0200
Subject: [PATCH 341/342] random: Use local locks for crng context access
Origin: https://git.kernel.org/cgit/linux/kernel/git/rt/linux-stable-rt.git/commit?id=78c61f9bc5797149c2dfbd84ee4c5ee0fdd9ab6c

The backport of 5f1bb112006b ("random: group initialization wait
functions") changed the upstream local locks to normal spin locks
because the local infrastructure in v4.19 is missing. As spin locks
are turned into sleeping locks for RT we have to add the local locks
back using the v4.19-rt API.

Signed-off-by: Daniel Wagner <dwagner@suse.de>
---
 drivers/char/random.c | 11 +++++++----
 1 file changed, 7 insertions(+), 4 deletions(-)

diff --git a/drivers/char/random.c b/drivers/char/random.c
index 2be38780a7f7..c06705a32246 100644
--- a/drivers/char/random.c
+++ b/drivers/char/random.c
@@ -53,6 +53,7 @@
 #include <linux/uaccess.h>
 #include <linux/siphash.h>
 #include <linux/uio.h>
+#include <linux/locallock.h>
 #include <crypto/chacha20.h>
 #include <crypto/blake2s.h>
 #include <asm/processor.h>
@@ -234,6 +235,7 @@ struct crng {
 static DEFINE_PER_CPU(struct crng, crngs) = {
 	.generation = ULONG_MAX
 };
+DEFINE_LOCAL_IRQ_LOCK(crngs_lock);
 
 /* Used by crng_reseed() and crng_make_state() to extract a new seed from the input pool. */
 static void extract_entropy(void *buf, size_t len);
@@ -362,7 +364,7 @@ static void crng_make_state(u32 chacha_state[CHACHA20_BLOCK_SIZE / sizeof(u32)],
 	if (unlikely(crng_has_old_seed()))
 		crng_reseed();
 
-	local_irq_save(flags);
+	local_lock_irqsave(crngs_lock, flags);
 	crng = raw_cpu_ptr(&crngs);
 
 	/*
@@ -387,7 +389,7 @@ static void crng_make_state(u32 chacha_state[CHACHA20_BLOCK_SIZE / sizeof(u32)],
 	 * should wind up here immediately.
 	 */
 	crng_fast_key_erasure(crng->key, chacha_state, random_data, random_data_len);
-	local_irq_restore(flags);
+	local_unlock_irqrestore(crngs_lock, flags);
 }
 
 static void _get_random_bytes(void *buf, size_t len)
@@ -512,6 +514,7 @@ struct batch_ ##type {								\
 static DEFINE_PER_CPU(struct batch_ ##type, batched_entropy_ ##type) = {	\
 	.position = UINT_MAX							\
 };										\
+static DEFINE_LOCAL_IRQ_LOCK(batched_entropy_lock_ ##type);			\
 										\
 type get_random_ ##type(void)							\
 {										\
@@ -527,7 +530,7 @@ type get_random_ ##type(void)							\
 		return ret;							\
 	}									\
 										\
-	local_irq_save(flags);		\
+	local_lock_irqsave(batched_entropy_lock_ ##type, flags);		\
 	batch = raw_cpu_ptr(&batched_entropy_##type);				\
 										\
 	next_gen = READ_ONCE(base_crng.generation);				\
@@ -541,7 +544,7 @@ type get_random_ ##type(void)							\
 	ret = batch->entropy[batch->position];					\
 	batch->entropy[batch->position] = 0;					\
 	++batch->position;							\
-	local_irq_restore(flags);		\
+	local_unlock_irqrestore(batched_entropy_lock_ ##type, flags);		\
 	return ret;								\
 }										\
 EXPORT_SYMBOL(get_random_ ##type);
