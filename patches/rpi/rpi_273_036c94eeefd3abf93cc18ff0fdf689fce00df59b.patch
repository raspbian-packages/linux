commit 036c94eeefd3abf93cc18ff0fdf689fce00df59b
Author: Emeric Vigier <emeric.vigier@savoirfairelinux.com>
Date:   Mon Jul 9 17:44:45 2012 -0400

    smsc95xx: support ethtool get_regs
    
    Inspired by implementation in smsc911x.c and smsc9420.c
    Tested on ARM/pandaboard running android
    
    Signed-off-by: Emeric Vigier <emeric.vigier@savoirfairelinux.com>
    Signed-off-by: David S. Miller <davem@davemloft.net>

Index: linux-3.2.46/drivers/net/usb/smsc95xx.c
===================================================================
--- linux-3.2.46.orig/drivers/net/usb/smsc95xx.c	2013-07-26 19:32:54.000000000 +0000
+++ linux-3.2.46/drivers/net/usb/smsc95xx.c	2013-07-26 19:37:23.000000000 +0000
@@ -582,6 +582,35 @@
 	return smsc95xx_write_eeprom(dev, ee->offset, ee->len, data);
 }
 
+static int smsc95xx_ethtool_getregslen(struct net_device *netdev)
+{
+	/* all smsc95xx registers */
+	return COE_CR - ID_REV + 1;
+}
+
+static void
+smsc95xx_ethtool_getregs(struct net_device *netdev, struct ethtool_regs *regs,
+			 void *buf)
+{
+	struct usbnet *dev = netdev_priv(netdev);
+	unsigned int i, j, retval;
+	u32 *data = buf;
+
+	retval = smsc95xx_read_reg(dev, ID_REV, &regs->version);
+	if (retval < 0) {
+		netdev_warn(netdev, "REGS: cannot read ID_REV\n");
+		return;
+	}
+
+	for (i = ID_REV, j = 0; i <= COE_CR; i += (sizeof(u32)), j++) {
+		retval = smsc95xx_read_reg(dev, i, &data[j]);
+		if (retval < 0) {
+			netdev_warn(netdev, "REGS: cannot read reg[%x]\n", i);
+			return;
+		}
+	}
+}
+
 static const struct ethtool_ops smsc95xx_ethtool_ops = {
 	.get_link	= usbnet_get_link,
 	.nway_reset	= usbnet_nway_reset,
@@ -593,6 +622,8 @@
 	.get_eeprom_len	= smsc95xx_ethtool_get_eeprom_len,
 	.get_eeprom	= smsc95xx_ethtool_get_eeprom,
 	.set_eeprom	= smsc95xx_ethtool_set_eeprom,
+	.get_regs_len	= smsc95xx_ethtool_getregslen,
+	.get_regs	= smsc95xx_ethtool_getregs,
 };
 
 static int smsc95xx_ioctl(struct net_device *netdev, struct ifreq *rq, int cmd)
