commit 8544300faae04c4fb4e3e1acc5ff9a9733f1acce
Author: popcornmix <popcornmix@gmail.com>
Date:   Tue Jun 26 15:54:11 2012 +0100

    Fixed issue with some keyboards giving too much data
     resulting in overrun of the input buffer and memory
     corruption causing an OOPS. We should be checking for the
     fact that we might get more data than we want. Thanks Naren.

Index: linux-3.2.46/drivers/usb/host/dwc_otg/dwc_otg_hcd_ddma.c
===================================================================
--- linux-3.2.46.orig/drivers/usb/host/dwc_otg/dwc_otg_hcd_ddma.c	2013-07-26 19:31:23.000000000 +0000
+++ linux-3.2.46/drivers/usb/host/dwc_otg/dwc_otg_hcd_ddma.c	2013-07-26 19:33:42.000000000 +0000
@@ -886,7 +886,7 @@
 	if (hc->ep_type == DWC_OTG_EP_TYPE_CONTROL) {
 	    if (qtd->control_phase == DWC_OTG_CONTROL_DATA) {
 		urb->actual_length += n_bytes - remain;
-		if (remain || urb->actual_length == urb->length) {
+		if (remain || urb->actual_length >= urb->length) {
 			/* 
 			 * For Control Data stage do not set urb->status=0 to prevent
 			 * URB callback. Set it when Status phase done. See below.
@@ -905,7 +905,7 @@
 	else { 
 	    /* BULK and INTR */
 	    urb->actual_length += n_bytes - remain;
-	    if (remain || urb->actual_length == urb->length) {
+	    if (remain || urb->actual_length >= urb->length) {
 		urb->status = 0;
 		*xfer_done = 1;
 	    }
Index: linux-3.2.46/drivers/usb/host/dwc_otg/dwc_otg_hcd_intr.c
===================================================================
--- linux-3.2.46.orig/drivers/usb/host/dwc_otg/dwc_otg_hcd_intr.c	2013-07-26 19:31:23.000000000 +0000
+++ linux-3.2.46/drivers/usb/host/dwc_otg/dwc_otg_hcd_intr.c	2013-07-26 19:33:42.000000000 +0000
@@ -567,7 +567,7 @@
 	   (urb->flags & URB_SEND_ZERO_PACKET) && (urb->actual_length == urb->length) &&
 	   !(urb->length % hc->max_packet)) {
 		xfer_done = 0;
-	} else if (short_read || urb->actual_length == urb->length) {
+	} else if (short_read || urb->actual_length >= urb->length) {
 		xfer_done = 1;
 		urb->status = 0;
 	}
@@ -1876,10 +1876,10 @@
 	} else if (hcint.b.xacterr && !hcd->core_if->dma_desc_enable) {
 		if (out_nak_enh) {
 			if (hcint.b.nyet || hcint.b.nak || hcint.b.ack) {
-				DWC_DEBUG("XactErr with NYET/NAK/ACK\n");
+				DWC_DEBUGPL(DBG_HCD, "XactErr with NYET/NAK/ACK\n");
 				qtd->error_count = 0;
 			} else {
-				DWC_DEBUG("XactErr without NYET/NAK/ACK\n");
+				DWC_DEBUGPL(DBG_HCD, "XactErr without NYET/NAK/ACK\n");
 			}
 		}
 
Index: linux-3.2.46/drivers/usb/host/dwc_otg/dwc_otg_hcd_linux.c
===================================================================
--- linux-3.2.46.orig/drivers/usb/host/dwc_otg/dwc_otg_hcd_linux.c	2013-07-26 19:33:38.000000000 +0000
+++ linux-3.2.46/drivers/usb/host/dwc_otg/dwc_otg_hcd_linux.c	2013-07-26 19:33:42.000000000 +0000
@@ -190,6 +190,7 @@
 		     uint32_t * port_addr)
 {
    struct urb *urb = (struct urb *)urb_handle;
+   struct usb_bus *bus;
 #if 1 //GRAYG - temporary
    if (NULL == urb_handle)
       DWC_ERROR("**** %s - NULL URB handle\n", __func__);//GRAYG
@@ -206,12 +207,18 @@
                 *hub_addr = 0; //GRAYG
                 // we probably shouldn't have a transaction translator if
                 // there's no associated hub?
-        } else
-                *hub_addr = urb->dev->tt->hub->devnum;
+        } else {
+		bus = hcd_to_bus(dwc_otg_hcd_to_hcd(hcd));
+		if (urb->dev->tt->hub == bus->root_hub)
+			*hub_addr = 0;
+		else
+			*hub_addr = urb->dev->tt->hub->devnum;
+	}
+	*port_addr = urb->dev->tt->multi ? urb->dev->ttport : 1;
    } else {
         *hub_addr = 0;
+	*port_addr = urb->dev->ttport;
    }
-   *port_addr = urb->dev->ttport;
    return 0;
 }
 
